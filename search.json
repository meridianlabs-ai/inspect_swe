[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Inspect SWE",
    "section": "",
    "text": "The inspect_swe package makes software engineering agents like Claude Code available as standard Inspect Agents. For example, here we use the claude_code() agent as the solver in an Inspect task:\nfrom inspect_ai import Task, task\nfrom inspect_ai.dataset import json_dataset\nfrom inspect_ai.scorer import model_graded_qa\n\nfrom inspect_swe import claude_code\n\n@task\ndef system_explorer() -&gt; Task:\n    return Task(\n        dataset=json_dataset(\"dataset.json\"),\n        solver=claude_code(),\n        scorer=model_graded_qa(),\n        sandbox=(\"docker\", \"Dockerfile\"),\n    )\nInspect SWE agents are implemented using the Inspect sandbox_agent_bridge(). Agents run inside the sample sandbox and their model API calls are proxied back to Inspect. This means that you can use any model with Inspect SWE agents and that features like token and time limits and log transcripts work as normal with the agents."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Inspect SWE",
    "section": "",
    "text": "The inspect_swe package makes software engineering agents like Claude Code available as standard Inspect Agents. For example, here we use the claude_code() agent as the solver in an Inspect task:\nfrom inspect_ai import Task, task\nfrom inspect_ai.dataset import json_dataset\nfrom inspect_ai.scorer import model_graded_qa\n\nfrom inspect_swe import claude_code\n\n@task\ndef system_explorer() -&gt; Task:\n    return Task(\n        dataset=json_dataset(\"dataset.json\"),\n        solver=claude_code(),\n        scorer=model_graded_qa(),\n        sandbox=(\"docker\", \"Dockerfile\"),\n    )\nInspect SWE agents are implemented using the Inspect sandbox_agent_bridge(). Agents run inside the sample sandbox and their model API calls are proxied back to Inspect. This means that you can use any model with Inspect SWE agents and that features like token and time limits and log transcripts work as normal with the agents."
  },
  {
    "objectID": "index.html#getting-started",
    "href": "index.html#getting-started",
    "title": "Inspect SWE",
    "section": "Getting Started",
    "text": "Getting Started\nInstall the inspect-swe package with:\npip install inspect-swe\nRead on below to learn about using the available agents (currently only Claude Code, but soon to include OpenAI Codex)."
  },
  {
    "objectID": "index.html#claude-code",
    "href": "index.html#claude-code",
    "title": "Inspect SWE",
    "section": "Claude Code",
    "text": "Claude Code\nWhile Claude Code is typically used in an interactive loop by developers, it can also run in an unattended mode where it works on a solution to the prompt without interactions. The claude_code() agent runs in this mode within the sandbox, and its model API calls are proxied back to Inspect for handling by the model provider for the current task.\n\n\n\n\n\n\nClaude Code Installation\n\n\n\nBy default, the agent will download the current stable version of Claude Code and copy it to the sandbox. You can also exercise more explicit control over which version of Claude Code is used—see the Installation section below for details.\n\n\n\nBasic Usage\nUse the claude_code() agent as you would any Inspect agent. For example, here we use it as the solver in an Inspect task:\nfrom inspect_ai import Task, task\nfrom inspect_ai.dataset import json_dataset\nfrom inspect_ai.scorer import model_graded_qa\n\nfrom inspect_swe import claude_code\n\n@task\ndef system_explorer() -&gt; Task:\n    return Task(\n        dataset=json_dataset(\"dataset.json\"),\n        solver=claude_code(),\n        scorer=model_graded_qa(),\n        sandbox=\"docker\",\n    )\nIf you want to try this out locally, see the system_explorer example.\n\n\nLog Viewer\nOne important productivity tip for working with the Claude Code agent is that the Messages view in the Log Viewer will provide the most coherent view of the agent’s path to the solution:\n\nWhile the Transcript view includes all of the same information, it also includes many additional model requests for supporting tasks (e.g. extracting the file paths from bash commands) which tend to distract from understanding the agent’s actions at a high level. Start with the Messages view, then use the transcript view as required for debugging.\n\n\nOptions\nThe following options are supported for customizing the behavior of the agent:\n\n\n\n\n\n\n\nOption\nDescription\n\n\n\n\nsystem_prompt\nAdditional system prompt to append to default system prompt.\n\n\nmcp_servers\nMCP servers (see MCP Servers below for details).\n\n\nallowed_tools\nParameter filters for built-in tools (see Tool Filters below for details).\n\n\ndisallowed_tools\nList of tool names to disallow entirely (see Tool Filters below for details).\n\n\nattempts\nAllow the agent to have multiple scored attempts at solving the task.\n\n\nmodel\nModel name to use for Opus and Sonnet calls (defaults to main model for task).\n\n\nsmall_model\nModel to use for Haiku calls (defaults to main model for task).\n\n\ncwd\nWorkding directory for Claude Code session.\n\n\nenv\nEnvironment variables to set for Claude Code.\n\n\nversion\nVersion of Claude Code to use (see Installation below for details)\n\n\n\nFor example, here we specify a custom system prompt and disable the WebFetch tool:\nclaude_code(\n    system_prompt=\"You are an ace system researcher.\",\n    disallowed_tools=[\"WebFetch\"]\n)\n\nTool Filters\nUse allowed_tools and disallowed_tools to control access to Claude’s built in tools. Note that allowed_tools enables you to filter allowed parameter values and disallowed_tools enables you to remove tools entirely. In other words, allowed_tools is not a complete list of what tools are available but rather just filters on tool parameters—to remove tools you need to explicitly set disallowed_tools.\nThese resources provide additional information on tool filtering:\n\nTools available to Claude documents the list of built-in tools\nHow to use Allowed Tools in Claude Code provides details on the supported syntax.\n\n\n\n\nMCP Servers\nYou can specify one or more Model Context Protocol (MCP) servers to provide additional tools to Claude Code. Servers are specified via the MCPServerConfig class and its Stdio and HTTP variants.\nFor example, here is a Dockerfile that makes the server-memory MPC server available in the sandbox container:\nFROM python:3.12-bookworm\n\n# nodejs (required by mcp server)\nRUN apt-get update && apt-get install -y --no-install-recommends \\\n    curl \\\n    && curl -fsSL https://deb.nodesource.com/setup_22.x | bash - \\\n    && apt-get install -y --no-install-recommends nodejs \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# memory mcp server\nRUN npx --yes @modelcontextprotocol/server-memory --version\n\n# run forever\nCMD [\"tail\", \"-f\", \"/dev/null\"]\nNote that we run the npx server during the build of the Dockerfile so that it is cached for use offline (below we’ll run it with the --offline option).\nWe can then use this MCP server in a task as follows:\nfrom inspect_ai import Task, task\nfrom inspect_ai.dataset import Sample\nfrom inspect_ai.tool import MCPServerConfigStdio\nfrom inspect_swe import claude_code\n\n@task\ndef web_search() -&gt; Task:\n    return Task(\n        dataset=[\n            Sample(\n                input=\"What transport protocols are supported in \"\n                + \" the 2025-03-26 version of the MCP spec?\"\n            )\n        ],\n        solver=claude_code(\n            system_prompt=\"Please use the WebSearch tool to \"\n            + \"research this question and the memory tools \"\n            + \"to keep track of your research.\",\n            mcp_servers=[\n                MCPServerConfigStdio(\n                    name=\"memory\",\n                    command=\"npx\",\n                    args=[\n                        \"--offline\", \n                        \"@modelcontextprotocol/server-memory\"\n                    ],\n                )\n            ] \n        ),\n        sandbox=(\"docker\", \"Dockerfile\"),\n    )\nNote that we run the MCP server using the --offline option so that it doesn’t require an internet connection (which it would normally use to check for updates to the package).\n\n\nInstallation\nBy default, the agent will download the current stable version of Claude Code and copy it to the sandbox. You can override this behaviour using the version option:\n\n\n\n\n\n\n\nOption\nDescription\n\n\n\n\n\"auto\"\nUse any available version of Claude Code in the sandbox, otherwise download the current stable version.\n\n\n\"sandbox\"\nUse the version of Claude Code in the sandbox (raises RuntimeError if not available in the sandbox)\n\n\n\"stable\"\nDownload and use the current stable version.\n\n\n\"latest\"\nDownload and use the very latest version.\n\n\n\"x.x.x\"\nDownload and use a specific version number.\n\n\n\nIf you don’t ever want to rely on automatic downloads of Claude Code (e.g. if you run your evaluations offline), you can use one of two approaches:\n\nPre-install the version of Claude Code you want to use in the sandbox, then use version=\"sandbox\":\nclaude_code(version=\"sandbox\")\nDownload the version of Claude Code you want to use into the cache, then specify that version explicitly:\n# download the agent binary during installation/configuration\ndownload_agent_binary(\"claude_code\", \"1.0.98\", \"linux-x64\")\n\n# reference that version in your task (no download will occur)\nclaude_code(version=\"1.0.98\")\nNote that the 5 most recently downloaded versions are retained in the cache.\n\n\n\nTroubleshooting\nIf Claude Code doesn’t appear to be working or working as expected, you can troubleshoot by dumping the Claude Code debug log after an evaluation task is complete. You can do this with:\ninspect trace dump --filter \"Claude Code\""
  }
]